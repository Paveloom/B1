#!/bin/bash

# Скрипт для стандартизации числа символов 
# табуляции в строках make-файлов

## Словарь чисел строк, занимаемых правилами
declare -A inds=( ['$(main_name)']='1' \
                  ['$(obj_path)%.o']='1' \
                  ['$(obj_main)']='1' \
                  ['input']='1' \
                  ['result']='14' \
                  ['result-r']='6' \
                  ['result-d']='2' \
                  ['result-c']='6' \
                  ['clean']='5' \
                  ['git']='3' \
                  ['git-am']='3' \
                  ['git-new']='6' \
                  ['git-clean']='1')


# Блок для файлов "./Make-файлы/Компиляция программ" и "./Пример/Makefile"

## Массив правил для текущего make-файла
rules=( '$(main_name)' '$(obj_path)%.o' '$(obj_main)' \
        'input' 'result' 'result-r' 'result-d' 'result-c' \
        'clean' )

## Цикл с определением пути к файлу для текущего цикла
for path in "./Make-файлы/Компиляция программ" "./Пример/Makefile"; do

     ## Задание начального значения счетчику строк
     i=0

     ## Задание начального значения текущего
     ## рассматриваемого элемента из массива правил
     j=0

     ## Задание начального значения допустимого количества символов табуляции
     k=0

     ## Главный цикл для проверки на наличие лишних символов табуляции
     while IFS= read -r line || [ -n "$line" ]; do
     
          ## Обновление счетчика строк
          i=$((i+1))

          ## Обновление числа найденных символов
          n=$(echo "$line" | grep -o "	" | wc -l)

          ## Проверка на допустимое количество символов табуляции
          if [ $n -gt $k ]; then
               
               echo
               echo "$path:"
               echo "В строке $i обнаружен лишний символ табуляции."
               echo

          elif [ $n -lt $k ]; then

               echo
               echo "$path:"
               echo "В строке $i не хватает символа табуляции."
               echo

          elif [ "$(echo $line | grep -o "${rules[$j]} :")" ]; then

               ## Получение числа следующих строк, на которых будет
               ## допустимым наличие одного символа табуляции
               m=${inds["${rules[$j]}"]}

               ## Вычисление номера строки, на которой закончится текущее правило
               m=$((i+m))

               ## Временное изменение числа допустимых символов табуляции
               k=1

          fi

          ## Проверка на попадание на последнюю строку рецепта текущего правила
          if [ "$i" = "$m" ]; then

               ## Обновление значения текущего рассматриваемого элемента из массива правил
               j=$((j+1))

               ## Возврат к начальному допустимому значению числа символов табуляции
               k=0

          fi

     done < "$path"

done


# Блок для файла "./Make-файлы/Компиляция программ, публикация кода на GitHub"

## Массив правил для текущего make-файла
rules=( '$(main_name)' '$(obj_path)%.o' '$(obj_main)' \
        'input' 'result' 'result-r' 'result-d' 'result-c' \
        'clean' 'git' 'git-am' 'git-new' 'git-clean' )

## Путь к текущему make-файлу
path="./Make-файлы/Компиляция программ, публикация кода на GitHub"

## Задание начального значения счетчику строк
i=0

## Задание начального значения текущего
## рассматриваемого элемента из массива правил
j=0

## Задание начального значения допустимого количества символов табуляции
k=0

## Главный цикл для проверки на наличие лишних символов табуляции
while IFS= read -r line || [ -n "$line" ]; do

     ## Обновление счетчика строк
     i=$((i+1))

     ## Обновление числа найденных символов
     n=$(echo "$line" | grep -o "	" | wc -l)

     ## Проверка на допустимое количество символов табуляции
     if [ $n -gt $k ]; then
          
          echo
          echo "$path:"
          echo "В строке $i обнаружен лишний символ табуляции."
          echo

     elif [ $n -lt $k ]; then

          echo
          echo "$path:"
          echo "В строке $i не хватает символа табуляции."
          echo

     elif [ "$(echo $line | grep -o "${rules[$j]} :")" ]; then

          ## Получение числа следующих строк, на которых будет
          ## допустимым наличие одного символа табуляции
          m=${inds["${rules[$j]}"]}

          ## Вычисление номера строки, на которой закончится текущее правило
          m=$((i+m))

          ## Временное изменение числа допустимых символов табуляции
          k=1

     fi

     ## Проверка на попадание на последнюю строку рецепта текущего правила
     if [ "$i" = "$m" ]; then

          ## Обновление значения текущего рассматриваемого элемента из массива правил
          j=$((j+1))

          ## Возврат к начальному допустимому значению числа символов табуляции
          k=0

     fi

done < "$path"


# Блок для файлов "../Make-файлы/Публикация кода на GitHub" и "../Makefile"

## Массив правил для текущего make-файла
rules=( 'git' 'git-am' 'git-new' 'git-clean' )

## Цикл с определением пути к файлу для текущего цикла
for path in "./Make-файлы/Публикация кода на GitHub" "./Makefile"; do

     ## Задание начального значения счетчику строк
     i=0

     ## Задание начального значения текущего
     ## рассматриваемого элемента из массива правил
     j=0

     ## Задание начального значения допустимого количества символов табуляции
     k=0

     ## Главный цикл для проверки на наличие лишних символов табуляции
     while IFS= read -r line || [ -n "$line" ]; do

          ## Обновление счетчика строк
          i=$((i+1))

          ## Обновление числа найденных символов
          n=$(echo "$line" | grep -o "	" | wc -l)

          ## Проверка на допустимое количество символов табуляции
          if [ $n -gt $k ]; then
               
               echo
               echo "$path:"
               echo "В строке $i обнаружен лишний символ табуляции."
               echo

          elif [ $n -lt $k ]; then

               echo
               echo "$path:"
               echo "В строке $i не хватает символа табуляции."
               echo

          elif [ "$(echo $line | grep -o "${rules[$j]} :")" ]; then

               ## Получение числа следующих строк, на которых будет
               ## допустимым наличие одного символа табуляции
               m=${inds["${rules[$j]}"]}

               ## Вычисление номера строки, на которой закончится текущее правило
               m=$((i+m))

               ## Временное изменение числа допустимых символов табуляции
               k=1

          fi

          ## Проверка на попадание на последнюю строку рецепта текущего правила
          if [ "$i" = "$m" ]; then

               ## Обновление значения текущего рассматриваемого элемента из массива правил
               j=$((j+1))

               ## Возврат к начальному допустимому значению числа символов табуляции
               k=0

          fi

     done < "$path"

done