#!/bin/bash

## Словарь чисел строк, занимаемых правилами
declare -A inds=( ['$(main_name)']='1' \
                  ['$(obj_path)%.o']='1' \
                  ['$(obj_main)']='1' \
                  ['input']='1' \
                  ['result']='14' \
                  ['result-r']='6' \
                  ['result-d']='2' \
                  ['result-c']='6' \
                  ['clean']='5' \
                  )


# Блок для файла "../Make-файлы/Компиляция программ"

## Путь к файлу для текущего цикла
path="../Make-файлы/Компиляция программ"

## Массив правил для текущего make-файла
rules=( '$(main_name)' '$(obj_path)%.o' '$(obj_main)' \
        'input' 'result' 'result-r' 'result-d' 'result-c' \
        'clean' )

## Задание начального значения счетчику строк
i=0

## Задание начального значения текущего
## рассматриваемого элемента из массива правил
j=0

## Задание начального значения допустимого количества символов табуляции
k=0

while IFS= read -r line || [ -n "$line" ]; do
    
     # Обновление счетчика строк
     i=$((i+1))

     # Проверка на допустимое количество символов табуляции
     if [ "$(echo "$line" | grep -o "	" | wc -l)" != "$k" ]; then
          
          echo
          echo "$path:"
          echo "В строке $i обнаружен лишний символ табуляции."
          echo

     elif [ "$(echo $line | grep -o "${rules[$j]} :")" ]; then

          # Получение числа следующих строк, на которых будет
          # допустимым наличие одного символа табуляции
          m=${inds["${rules[$j]}"]}

          # Вычисление номера строки, на которой закончится текущее правило
          m=$((i+m))

          # Временное изменение числа допустимых символов табуляции
          k=1

     fi

     # Проверка на попадание на последнюю строку рецепта текущего правила
     if [ "$i" = "$m" ]; then

          # Обновление значения текущего рассматриваемого элемента из массива правил
          j=$((j+1))

          # Возврат к начальному допустимому значению числа символов табуляции
          k=0

     fi

done < "$path"