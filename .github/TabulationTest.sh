#!/bin/bash

## Словарь чисел строк, занимаемых правилами
declare -A inds=( ['$(main_name)']='1' \
                  ['$(obj_path)%.o']='1' \
                  ['$(obj_main)']='1' \
                  ['input']='1' \
                  ['result']='14' \
                  ['result-r']='6' \
                  ['result-d']='2' \
                  ['result-c']='6' \
                  ['clean']='5' \
                  )


# Блок для файлов "../Make-файлы/Компиляция программ" и "../Пример/Makefile"

## Массив правил для текущего make-файла
rules=( '$(main_name)' '$(obj_path)%.o' '$(obj_main)' \
        'input' 'result' 'result-r' 'result-d' 'result-c' \
        'clean' )

## Цикл с определением пути к файлу для текущего цикла
for path in "../Make-файлы/Компиляция программ" "../Пример/Makefile"; do

     ## Задание начального значения счетчику строк
     i=0

     ## Задание начального значения текущего
     ## рассматриваемого элемента из массива правил
     j=0

     ## Задание начального значения допустимого количества символов табуляции
     k=0

     ## Главный цикл для проверки на наличие лишних символов табуляции
     while IFS= read -r line || [ -n "$line" ]; do
     
          # Обновление счетчика строк
          i=$((i+1))

          # Проверка на допустимое количество символов табуляции
          if [ "$(echo "$line" | grep -o "	" | wc -l)" != "$k" ]; then
               
               echo
               echo "$path:"
               echo "В строке $i обнаружен лишний символ табуляции."
               echo

          elif [ "$(echo $line | grep -o "${rules[$j]} :")" ]; then

               # Получение числа следующих строк, на которых будет
               # допустимым наличие одного символа табуляции
               m=${inds["${rules[$j]}"]}

               # Вычисление номера строки, на которой закончится текущее правило
               m=$((i+m))

               # Временное изменение числа допустимых символов табуляции
               k=1

          fi

          # Проверка на попадание на последнюю строку рецепта текущего правила
          if [ "$i" = "$m" ]; then

               # Обновление значения текущего рассматриваемого элемента из массива правил
               j=$((j+1))

               # Возврат к начальному допустимому значению числа символов табуляции
               k=0

          fi

     done < "$path"

done